%FIRPM  Parks-McClellan 最適等リップル FIR フィルタを設計
%
%   B = FIRPM(N,F,A) は、ミニマックス規範を使って、ベクトル F と A で表される
%   周波数とゲインの関係を最適近似する長さ N+1 の線形位相 FIR フィルタ (係数は
%   実数で対称) を設計します。F は、0 と 1 の昇順で、対の周波数帯域エッジの
%   ベクトルです。1 は、ナイキスト周波数、あるいはサンプリング周波数の半分に
%   対応します。少なくとも 1 つの周波数帯域は、非零の幅でなければなりません。
%   A は、結果のフィルタ B の希望する周波数応答の振幅を表わす実数ベクトルで、
%   F と同じサイズでなければなりません。
%
%   k が奇数の場合、希望の振幅は、点 (F(k),A(k)) と (F(k+1),A(k+1)) を
%   直線で結んだものです。FIRPM は、"遷移帯域"、または、"don't care" 
%   領域として、奇数 k に対する F(k+1) と F(k+2) 間の帯域を扱います。
%   希望する周波数応答の振幅は遷移領域をもつ、区分的な線形関数になります。
%   この際、二乗和誤差は最小になります。
%
%   Fs/2 で 0 以外のゲインをもつフィルタ、たとえば、ハイパス、バンドストップ
%   フィルタは、N が偶数でなければなりません。それ以外の場合は、N は 1 で
%   インクリメントされます。あるいは、タイプ 4 の線形位相フィルタを設計して 
%   N の増加を避けるために、後に続くフラグに 'h' を利用することが可能です。
%
%   B = FIRPM(N,F,A,W) は、ベクトル W の重みを使って近似に重みを付けます。
%   W は 1 つの帯域に対して 1 つの入力をもち (そのため、F および A の長さの
%   半分です)、これにより、ある周波数帯域での誤差の最小化を他の周波数帯域での
%   誤差の最小化と比べて重みを付けて強調することができます。
%
%   B = FIRPM(N,F,A,'Hilbert') と B = FIRPM(N,F,A,W,'Hilbert') は、つぎの
%   奇数の対称性を満たす線形位相フィルタを設計します。k = 1, ..., N+1 
%   に対して、B(k) = -B(N+2-k) です。特別な場合として、全帯域に渡り近似的に
%   振幅が 1 であるヒルベルト変換があります。
%   たとえば、B = FIRPM(30,[.1 .9],...[1 1],'Hilbert') です。
%
%   B = FIRPM(N,F,A,'differentiator') と B = FIRPM(N,F,A,W,'differentiator') 
%   は、奇数対称をもちますが、0 でない振幅帯域に対して特別な重み付けを行う
%   フィルタ設計を行います。重みは、重み W を乗算した周波数の逆数と考えられます。
%   そのため、フィルタは、高周波数よりも低周波数での近似のほうが適しています。
%   これは、FIR 微分器を設計します。
%
%   B = FIRPM(...,{LGRID}) は、周波数グリッドの密度をコントロールする整数を
%   含む 1 行 1 列のセル配列 {LGRID} を使います。周波数グリッドサイズは、
%   おおまかに LGRID*N/2*BW の周波数点数になります。ここで、BW は、F により
%   カバーされる全帯域 [0,1] の中に含まれるものです。LGRID は、デフォルトで 
%   16 ですが、設定する場合は、それより大きい値を使います。LGRID を増加させると、
%   より厳密な意味で等リップルになりますが計算時間が長くなります。
%
%   [B,ERR] = FIRPM(...) は、リップルの最大の高さを ERR に返します。
%
%[   B,ERR,RES] = FIRPM(...) は、つぎのメンバをもつオプションの計算結果を含む
%    構造体 RES を返します。
%
%      RES.fgrid:フィルタ設計の最適化に使用する周波数グリッドを含むベクトル
%        RES.des:fgrid の各点に対する希望する周波数応答
%         RES.wt:fgrid の中の各点に対する重み
%          RES.H:グリッド内の各点に対する実際の周波数応答
%      RES.error:周波数グリッド (希望-実際) の各点での誤差
%      RES.iextr:余分な周波数の fgrid のインデックスベクトル
%      RES.fextr:余分な周波数のベクトル
%
%   FIRPM は、CFIRPM と同様、希望する周波数応答を定義する関数を書き込む
%   ことの可能な "関数の関数" です。
%
%   B=FIRPM(N,F,@fresp,W) は、関数ハンドル @fresp で返されるような、
%   希望する周波数応答への最良近似となる N+1 の FIR フィルタを返します。
%   関数は、つぎのシンタックスを使って FIRPM 内から呼び出されます。
%                    [DH,DW] = fresp(N,F,GF,W);
%   ここで、
%   N は、フィルタの次数です。
%   F は 0 と +1 の間で単調増加する周波数帯域エッジのベクトルです。ここで 
%   1 はナイキスト周波数です。周波数帯域は、k が奇数の場合 F(k) から 
%   F(k+1) の領域で、k が偶数の場合の F(k+1) から F(k+2) の区間は、最適化の
%   間の "遷移帯域" または "don't care" 領域です。
%   GF は FIRPM で指定した各周波数帯域全体を線形補間したグリッド点のベクトルで
%   評価される応答関数における周波数グリッドを定義します。
%   W は最適化の間に使用される、帯域に 1 つの正の重みで実数のベクトルです。
%   W はオプションです。指定されない場合、'fresp' に渡される前に、同一の
%   重みに設定されます。
%   DH と DW は、グリッド GF 内の各周波数で評価される、希望する複素周波数
%   応答と最適化の重みベクトルです。
%
%   FIRPM であらかじめ定義された周波数応答の関数ハンドルは @firpmfrf ですが、
%   ユーザ定義の関数を記述することが可能です。詳細は、PRIVATE/FIRPMFRF の
%   ヘルプを参照してください。
%
%   B=FIRPM(N,F,{@fresp,P1,P2,...},W) は、応答の関数ハンドル @fresp に渡す 
%   オプションの引数 P1, P2,... を指定します。
%
%   B=FIRPM(N,F,A,W) は B=FIRPM(N,F,{@firpmfrf,A},W) と同義です。ここで、
%   A は Ｆ の各帯域における振幅応答のベクトルです。
%
%   FIRPM は、通常、対称 (even: 偶数) FIR フィルタを設計します。
%   B=FIRPM(...,'h') と B=FIRPM(...,'d') は、非対称 (odd: 奇数) フィルタを
%   設計します。各周波数応答の関数ハンドル @fresp は、'h' または 'd' 
%   フラグがない場合、偶数%か奇数フィルタのいずれかを設計するため、FIRPM を
%   呼び出すことができます。これはつぎのように行ないます。
%         SYM = fresp('defaults',{N,F,[],W,P1,P2,...})
%   FIRPM は、@fresp が SYM = 'even' または SYM = 'odd' を返すものと想定します。
%   @fresp がこの呼び出しをサポートしない場合、FIRPM は 'even' の対称であるもの
%   と仮定します。
%
%   % 長さ 31 のローパスフィルタの例:
%   	h=firpm(30,[0 .1 .2 .5]*2,[1 1 0 0]);
%
%   % ローパスの微分器の例:
%   	h=firpm(44,[0 .3 .4 1],[0 .2 0 0],'differentiator');
%
%   % タイプ 4 のハイパスフィルタの例:
%       h=firpm(25,[0 .4 .5 1],[0 0 1 1],'h');
%
%   参考 FIRPMORD, CFIRPM, FIRLS, FIR1, FIR2, BUTTER, CHEBY1, CHEBY2,
%        ELLIP, FREQZ, FILTER, and, in the Filter Design Toolbox, FIRGR.


%   Copyright 1988-2007 The MathWorks, Inc.
